# 3. 객체 지향

객체 지향의 장점: 설계부터 구현까지 객체라는 하나의 일관된 관점으로 문제를 풀어나갈 수 있음

객체 지향 패러다임의 핵심

- 역할: 협력 안에서 수행하는 책임들이 모여서 이루는 기능
- 책임: 협력에 참여하기 위해 각자 수행하는 로직
- 협력: 기능 수행을 위해 객체 간 상호작용

자율적인 객체의 공동체 -> 의인화

## 3.1. 협력

메세지 전송(message sending)
- 객체가 다른 객체에게 협력을 구하는 유일한 수단
- 메시지를 수신한(협력 요청) 객체는 메서드를 실행해 요청에 응답함

왜 함수가 아니라 메서드인가?
- 자기 자신의 방법으로 `책임`을 수행하는 것

객체를 `자율적`으로 만드는 가장 기본적인 방법
- 캡슐화
  - 변경에 대한 파급효과를 제한하는 것

객체의 행동을 결정하는 것
- 객체가 참여하는 협력

> 상태는 객체가 협력하는 데 필요한 정보에 의해 결정되고  
> 협력 안에서 객체가 처리할 메세지로 결정됨  
> 협력은 객체 설계에 필요한 문맥을 제공  

## 3.2. 책임

객체의 책임은
- 무엇을 알고 있는가
- 무엇을 할 수 있는가

하는 것
- 객체를 생성하거나 계산을 하는 등의 자율적으로 하는 것
- 다른 객체의 행동을 시작 시키는 것(메세지, 협력)
- 다른 객체의 활동을 제어하고 조절

아는 것
- 사적인 정보에 대해서 아는 것
- 관련된 객체에 대해서 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해서 아는 것

책임 할당
`정보 전문가 패턴`

### 3.2.1. 메세지가 객체를 결정한다

- 책임을 할당하는데 필요한 메세지를 먼저 식별하고 메세지를 처리할 객체를 나중에 선택

1. 최소한의 인터페이스
2. 충분히 추상적인 인터페이스

### 3.2.2. 행동이 상태를 결정한다

OOP의 가장 초보적인 실수
- 상태를 결정하고, 상태에 필요한 행동을 만듬
  - 내부 구현이 퍼블릭 인터페이스에 노출이 됨 -> 캡슐화 저해

## 3.3. 역할

잘 이어붙이기? 뭐 이건 당연함.

협력 관계를 잘 구성
-> policy(역할, 슬롯) 예제

# 4. 상속 비판

코드 재사용을 목적으로 상속을 사용하면 발생할 수 있는 문제점들에 대해 고민해보자.  

1. 불필요한 인터페이스 상속 문제
2. 메서드 오버라이딩 문제
3. 부모 클래스와 자식 클래스의 동시 수정 문제
   1. 부모 클래스가 노출됨 -> 캡슐화 깨짐

코드 재사용이 목적이라면 상속 보다는 합성을 사용할 것
- 상속 관계: 클래스 간 정적인 관계
- 합성 관계: 객체 간 동적인 관계

상속이 필요한 곳이 어디일까?  
- 타입 계층 구조화